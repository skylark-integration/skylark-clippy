{"version":3,"sources":["skylark-clippy.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-clippy.js","sourcesContent":["define('skylark-clippy/Queue',['skylark-jquery'], function ($) {\n    'use strict';\n    class Queue {\n        constructor(onEmptyCallback) {\n            this._queue = [];\n            this._onEmptyCallback = onEmptyCallback;\n        }\n        queue(func) {\n            this._queue.push(func);\n            if (this._queue.length === 1 && !this._active) {\n                this._progressQueue();\n            }\n        }\n        _progressQueue() {\n            if (!this._queue.length) {\n                this._onEmptyCallback();\n                return;\n            }\n            let f = this._queue.shift();\n            this._active = true;\n            let completeFunction = $.proxy(this.next, this);\n            f(completeFunction);\n        }\n        clear() {\n            this._queue = [];\n        }\n        next() {\n            this._active = false;\n            this._progressQueue();\n        }\n    }\n\n    return Queue;\n});\ndefine('skylark-clippy/Animator',['skylark-jquery'], function ($) {\n    'use strict';\n    class Animator {\n        constructor(el, path, data, sounds) {\n            this._el = el;\n            this._data = data;\n            this._path = path;\n            this._currentFrameIndex = 0;\n            this._currentFrame = undefined;\n            this._exiting = false;\n            this._currentAnimation = undefined;\n            this._endCallback = undefined;\n            this._started = false;\n            this._sounds = {};\n            this.currentAnimationName = undefined;\n            this.preloadSounds(sounds);\n            this._overlays = [this._el];\n            let curr = this._el;\n            this._setupElement(this._el);\n            for (let i = 1; i < this._data.overlayCount; i++) {\n                let inner = this._setupElement($('<div></div>'));\n                curr.append(inner);\n                this._overlays.push(inner);\n                curr = inner;\n            }\n        }\n        _setupElement(el) {\n            let frameSize = this._data.framesize;\n            el.css('display', 'none');\n            el.css({\n                width: frameSize[0],\n                height: frameSize[1]\n            });\n            el.css('background', \"url('\" + this._path + \"/map.png') no-repeat\");\n            return el;\n        }\n        animations() {\n            let r = [];\n            let d = this._data.animations;\n            for (let n in d) {\n                r.push(n);\n            }\n            return r;\n        }\n        preloadSounds(sounds) {\n            for (let i = 0; i < this._data.sounds.length; i++) {\n                let snd = this._data.sounds[i];\n                let uri = sounds[snd];\n                if (!uri)\n                    continue;\n                this._sounds[snd] = new Audio(uri);\n            }\n        }\n        hasAnimation(name) {\n            return !!this._data.animations[name];\n        }\n        exitAnimation() {\n            this._exiting = true;\n        }\n        showAnimation(animationName, stateChangeCallback) {\n            this._exiting = false;\n            if (!this.hasAnimation(animationName)) {\n                return false;\n            }\n            this._currentAnimation = this._data.animations[animationName];\n            this.currentAnimationName = animationName;\n            if (!this._started) {\n                this._step();\n                this._started = true;\n            }\n            this._currentFrameIndex = 0;\n            this._currentFrame = undefined;\n            this._endCallback = stateChangeCallback;\n            return true;\n        }\n        _draw() {\n            let images = [];\n            if (this._currentFrame)\n                images = this._currentFrame.images || [];\n            for (let i = 0; i < this._overlays.length; i++) {\n                if (i < images.length) {\n                    let xy = images[i];\n                    let bg = -xy[0] + 'px ' + -xy[1] + 'px';\n                    this._overlays[i].css({\n                        'background-position': bg,\n                        'display': 'block'\n                    });\n                } else {\n                    this._overlays[i].css('display', 'none');\n                }\n            }\n        }\n        _getNextAnimationFrame() {\n            if (!this._currentAnimation)\n                return undefined;\n            if (!this._currentFrame)\n                return 0;\n            let currentFrame = this._currentFrame;\n            let branching = this._currentFrame.branching;\n            if (this._exiting && currentFrame.exitBranch !== undefined) {\n                return currentFrame.exitBranch;\n            } else if (branching) {\n                let rnd = Math.random() * 100;\n                for (let i = 0; i < branching.branches.length; i++) {\n                    let branch = branching.branches[i];\n                    if (rnd <= branch.weight) {\n                        return branch.frameIndex;\n                    }\n                    rnd -= branch.weight;\n                }\n            }\n            return this._currentFrameIndex + 1;\n        }\n        _playSound() {\n            let s = this._currentFrame.sound;\n            if (!s)\n                return;\n            let audio = this._sounds[s];\n            if (audio)\n                audio.play();\n        }\n        _atLastFrame() {\n            return this._currentFrameIndex >= this._currentAnimation.frames.length - 1;\n        }\n        _step() {\n            if (!this._currentAnimation)\n                return;\n            let newFrameIndex = Math.min(this._getNextAnimationFrame(), this._currentAnimation.frames.length - 1);\n            let frameChanged = !this._currentFrame || this._currentFrameIndex !== newFrameIndex;\n            this._currentFrameIndex = newFrameIndex;\n            if (!(this._atLastFrame() && this._currentAnimation.useExitBranching)) {\n                this._currentFrame = this._currentAnimation.frames[this._currentFrameIndex];\n            }\n            this._draw();\n            this._playSound();\n            this._loop = window.setTimeout($.proxy(this._step, this), this._currentFrame.duration);\n            if (this._endCallback && frameChanged && this._atLastFrame()) {\n                if (this._currentAnimation.useExitBranching && !this._exiting) {\n                    this._endCallback(this.currentAnimationName, Animator.States.WAITING);\n                } else {\n                    this._endCallback(this.currentAnimationName, Animator.States.EXITED);\n                }\n            }\n        }\n        pause() {\n            window.clearTimeout(this._loop);\n        }\n        resume() {\n            this._step();\n        }\n    }\n    \n    Animator.States = {\n        WAITING: 1,\n        EXITED: 0\n    };\n\n    return Animator;\n});\ndefine('skylark-clippy/Balloon',['skylark-jquery'], function ($) {\n    'use strict';\n    class Balloon {\n        constructor(targetEl) {\n            this._targetEl = targetEl;\n            this._hidden = true;\n            this._setup();\n            this.WORD_SPEAK_TIME = 200;\n            this.CLOSE_BALLOON_DELAY = 2000;\n            this._BALLOON_MARGIN = 15;\n        }\n        _setup() {\n            this._balloon = $('<div class=\"clippy-balloon\"><div class=\"clippy-tip\"></div><div class=\"clippy-content\"></div></div> ').hide();\n            this._content = this._balloon.find('.clippy-content');\n            $(document.body).append(this._balloon);\n        }\n        reposition() {\n            let sides = [\n                'top-left',\n                'top-right',\n                'bottom-left',\n                'bottom-right'\n            ];\n            for (let i = 0; i < sides.length; i++) {\n                let s = sides[i];\n                this._position(s);\n                if (!this._isOut())\n                    break;\n            }\n        }\n        _position(side) {\n            let o = this._targetEl.offset();\n            let h = this._targetEl.height();\n            let w = this._targetEl.width();\n            o.top -= $(window).scrollTop();\n            o.left -= $(window).scrollLeft();\n            let bH = this._balloon.outerHeight();\n            let bW = this._balloon.outerWidth();\n            this._balloon.removeClass('clippy-top-left');\n            this._balloon.removeClass('clippy-top-right');\n            this._balloon.removeClass('clippy-bottom-right');\n            this._balloon.removeClass('clippy-bottom-left');\n            let left, top;\n            switch (side) {\n            case 'top-left':\n                left = o.left + w - bW;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'top-right':\n                left = o.left;\n                top = o.top - bH - this._BALLOON_MARGIN;\n                break;\n            case 'bottom-right':\n                left = o.left;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n            case 'bottom-left':\n                left = o.left + w - bW;\n                top = o.top + h + this._BALLOON_MARGIN;\n                break;\n            }\n            this._balloon.css({\n                top: top,\n                left: left\n            });\n            this._balloon.addClass('clippy-' + side);\n        }\n        _isOut() {\n            let o = this._balloon.offset();\n            let bH = this._balloon.outerHeight();\n            let bW = this._balloon.outerWidth();\n            let wW = $(window).width();\n            let wH = $(window).height();\n            let sT = $(document).scrollTop();\n            let sL = $(document).scrollLeft();\n            let top = o.top - sT;\n            let left = o.left - sL;\n            let m = 5;\n            if (top - m < 0 || left - m < 0)\n                return true;\n            return top + bH + m > wH || left + bW + m > wW;\n        }\n        speak(complete, text, hold) {\n            this._hidden = false;\n            this.show();\n            let c = this._content;\n            c.height('auto');\n            c.width('auto');\n            c.text(text);\n            c.height(c.height());\n            c.width(c.width());\n            c.text('');\n            this.reposition();\n            this._complete = complete;\n            this._sayWords(text, hold, complete);\n        }\n        show() {\n            if (this._hidden)\n                return;\n            this._balloon.show();\n        }\n        hide(fast) {\n            if (fast) {\n                this._balloon.hide();\n                return;\n            }\n            this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);\n        }\n        _finishHideBalloon() {\n            if (this._active)\n                return;\n            this._balloon.hide();\n            this._hidden = true;\n            this._hiding = null;\n        }\n        _sayWords(text, hold, complete) {\n            this._active = true;\n            this._hold = hold;\n            let words = text.split(/[^\\S-]/);\n            let time = this.WORD_SPEAK_TIME;\n            let el = this._content;\n            let idx = 1;\n            this._addWord = $.proxy(function () {\n                if (!this._active)\n                    return;\n                if (idx > words.length) {\n                    delete this._addWord;\n                    this._active = false;\n                    if (!this._hold) {\n                        complete();\n                        this.hide();\n                    }\n                } else {\n                    el.text(words.slice(0, idx).join(' '));\n                    idx++;\n                    this._loop = window.setTimeout($.proxy(this._addWord, this), time);\n                }\n            }, this);\n            this._addWord();\n        }\n        close() {\n            if (this._active) {\n                this._hold = false;\n            } else if (this._hold) {\n                this._complete();\n            }\n        }\n        pause() {\n            window.clearTimeout(this._loop);\n            if (this._hiding) {\n                window.clearTimeout(this._hiding);\n                this._hiding = null;\n            }\n        }\n        resume() {\n            if (this._addWord) {\n                this._addWord();\n            } else if (!this._hold && !this._hidden) {\n                this._hiding = window.setTimeout($.proxy(this._finishHideBalloon, this), this.CLOSE_BALLOON_DELAY);\n            }\n        }\n    }\n\n    return Balloon;\n});\ndefine('skylark-clippy/Agent',[\n    'skylark-jquery',\n    './Queue',\n    './Animator',\n    './Balloon'\n], function ($, Queue, Animator, Balloon) {\n    'use strict';\n     class Agent {\n        constructor(path, data, sounds) {\n            this.path = path;\n            this._queue = new Queue($.proxy(this._onQueueEmpty, this));\n            this._el = $('<div class=\"clippy\"></div>').hide();\n            $(document.body).append(this._el);\n            this._animator = new Animator(this._el, path, data, sounds);\n            this._balloon = new Balloon(this._el);\n            this._setupEvents();\n        }\n        gestureAt(x, y) {\n            let d = this._getDirection(x, y);\n            let gAnim = 'Gesture' + d;\n            let lookAnim = 'Look' + d;\n            let animation = this.hasAnimation(gAnim) ? gAnim : lookAnim;\n            return this.play(animation);\n        }\n        hide(fast, callback) {\n            this._hidden = true;\n            let el = this._el;\n            this.stop();\n            if (fast) {\n                this._el.hide();\n                this.stop();\n                this.pause();\n                if (callback)\n                    callback();\n                return;\n            }\n            return this._playInternal('Hide', function () {\n                el.hide();\n                this.pause();\n                if (callback)\n                    callback();\n            });\n        }\n        moveTo(x, y, duration) {\n            let dir = this._getDirection(x, y);\n            let anim = 'Move' + dir;\n            if (duration === undefined)\n                duration = 1000;\n            this._addToQueue(function (complete) {\n                if (duration === 0) {\n                    this._el.css({\n                        top: y,\n                        left: x\n                    });\n                    this.reposition();\n                    complete();\n                    return;\n                }\n                if (!this.hasAnimation(anim)) {\n                    this._el.animate({\n                        top: y,\n                        left: x\n                    }, duration, complete);\n                    return;\n                }\n                let callback = $.proxy(function (name, state) {\n                    if (state === Animator.States.EXITED) {\n                        complete();\n                    }\n                    if (state === Animator.States.WAITING) {\n                        this._el.animate({\n                            top: y,\n                            left: x\n                        }, duration, $.proxy(function () {\n                            this._animator.exitAnimation();\n                        }, this));\n                    }\n                }, this);\n                this._playInternal(anim, callback);\n            }, this);\n        }\n        _playInternal(animation, callback) {\n            if (this._isIdleAnimation() && this._idleDfd && this._idleDfd.state() === 'pending') {\n                this._idleDfd.done($.proxy(function () {\n                    this._playInternal(animation, callback);\n                }, this));\n            }\n            this._animator.showAnimation(animation, callback);\n        }\n        play(animation, timeout, cb) {\n            if (!this.hasAnimation(animation))\n                return false;\n            if (timeout === undefined)\n                timeout = 5000;\n            this._addToQueue(function (complete) {\n                let completed = false;\n                let callback = function (name, state) {\n                    if (state === Animator.States.EXITED) {\n                        completed = true;\n                        if (cb)\n                            cb();\n                        complete();\n                    }\n                };\n                if (timeout) {\n                    window.setTimeout($.proxy(function () {\n                        if (completed)\n                            return;\n                        this._animator.exitAnimation();\n                    }, this), timeout);\n                }\n                this._playInternal(animation, callback);\n            }, this);\n            return true;\n        }\n        show(fast) {\n            this._hidden = false;\n            if (fast) {\n                this._el.show();\n                this.resume();\n                this._onQueueEmpty();\n                return;\n            }\n            if (this._el.css('top') === 'auto' || !this._el.css('left') === 'auto') {\n                let left = $(window).width() * 0.8;\n                let top = ($(window).height() + $(document).scrollTop()) * 0.8;\n                this._el.css({\n                    top: top,\n                    left: left\n                });\n            }\n            this.resume();\n            return this.play('Show');\n        }\n        speak(text, hold) {\n            this._addToQueue(function (complete) {\n                this._balloon.speak(complete, text, hold);\n            }, this);\n        }\n        closeBalloon() {\n            this._balloon.hide();\n        }\n        delay(time) {\n            time = time || 250;\n            this._addToQueue(function (complete) {\n                this._onQueueEmpty();\n                window.setTimeout(complete, time);\n            });\n        }\n        stopCurrent() {\n            this._animator.exitAnimation();\n            this._balloon.close();\n        }\n        stop() {\n            this._queue.clear();\n            this._animator.exitAnimation();\n            this._balloon.hide();\n        }\n        hasAnimation(name) {\n            return this._animator.hasAnimation(name);\n        }\n        animations() {\n            return this._animator.animations();\n        }\n        animate() {\n            let animations = this.animations();\n            let anim = animations[Math.floor(Math.random() * animations.length)];\n            if (anim.indexOf('Idle') === 0) {\n                return this.animate();\n            }\n            return this.play(anim);\n        }\n        _getDirection(x, y) {\n            let offset = this._el.offset();\n            let h = this._el.height();\n            let w = this._el.width();\n            let centerX = offset.left + w / 2;\n            let centerY = offset.top + h / 2;\n            let a = centerY - y;\n            let b = centerX - x;\n            let r = Math.round(180 * Math.atan2(a, b) / Math.PI);\n            if (-45 <= r && r < 45)\n                return 'Right';\n            if (45 <= r && r < 135)\n                return 'Up';\n            if (135 <= r && r <= 180 || -180 <= r && r < -135)\n                return 'Left';\n            if (-135 <= r && r < -45)\n                return 'Down';\n            return 'Top';\n        }\n        _onQueueEmpty() {\n            if (this._hidden || this._isIdleAnimation())\n                return;\n            let idleAnim = this._getIdleAnimation();\n            this._idleDfd = $.Deferred();\n            this._animator.showAnimation(idleAnim, $.proxy(this._onIdleComplete, this));\n        }\n        _onIdleComplete(name, state) {\n            if (state === Animator.States.EXITED) {\n                this._idleDfd.resolve();\n            }\n        }\n        _isIdleAnimation() {\n            let c = this._animator.currentAnimationName;\n            return c && c.indexOf('Idle') === 0;\n        }\n        _getIdleAnimation() {\n            let animations = this.animations();\n            let r = [];\n            for (let i = 0; i < animations.length; i++) {\n                let a = animations[i];\n                if (a.indexOf('Idle') === 0) {\n                    r.push(a);\n                }\n            }\n            let idx = Math.floor(Math.random() * r.length);\n            return r[idx];\n        }\n        _setupEvents() {\n            $(window).on('resize', $.proxy(this.reposition, this));\n            this._el.on('mousedown', $.proxy(this._onMouseDown, this));\n            this._el.on('dblclick', $.proxy(this._onDoubleClick, this));\n        }\n        _onDoubleClick() {\n            if (!this.play('ClickedOn')) {\n                this.animate();\n            }\n        }\n        reposition() {\n            if (!this._el.is(':visible'))\n                return;\n            let o = this._el.offset();\n            let bH = this._el.outerHeight();\n            let bW = this._el.outerWidth();\n            let wW = $(window).width();\n            let wH = $(window).height();\n            let sT = $(window).scrollTop();\n            let sL = $(window).scrollLeft();\n            let top = o.top - sT;\n            let left = o.left - sL;\n            let m = 5;\n            if (top - m < 0) {\n                top = m;\n            } else if (top + bH + m > wH) {\n                top = wH - bH - m;\n            }\n            if (left - m < 0) {\n                left = m;\n            } else if (left + bW + m > wW) {\n                left = wW - bW - m;\n            }\n            this._el.css({\n                left: left,\n                top: top\n            });\n            this._balloon.reposition();\n        }\n        _onMouseDown(e) {\n            e.preventDefault();\n            this._startDrag(e);\n        }\n        _startDrag(e) {\n            this.pause();\n            this._balloon.hide(true);\n            this._offset = this._calculateClickOffset(e);\n            this._moveHandle = $.proxy(this._dragMove, this);\n            this._upHandle = $.proxy(this._finishDrag, this);\n            $(window).on('mousemove', this._moveHandle);\n            $(window).on('mouseup', this._upHandle);\n            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);\n        }\n        _calculateClickOffset(e) {\n            let mouseX = e.pageX;\n            let mouseY = e.pageY;\n            let o = this._el.offset();\n            return {\n                top: mouseY - o.top,\n                left: mouseX - o.left\n            };\n        }\n        _updateLocation() {\n            this._el.css({\n                top: this._targetY,\n                left: this._targetX\n            });\n            this._dragUpdateLoop = window.setTimeout($.proxy(this._updateLocation, this), 10);\n        }\n        _dragMove(e) {\n            e.preventDefault();\n            let x = e.clientX - this._offset.left;\n            let y = e.clientY - this._offset.top;\n            this._targetX = x;\n            this._targetY = y;\n        }\n        _finishDrag() {\n            window.clearTimeout(this._dragUpdateLoop);\n            $(window).off('mousemove', this._moveHandle);\n            $(window).off('mouseup', this._upHandle);\n            this._balloon.show();\n            this.reposition();\n            this.resume();\n        }\n        _addToQueue(func, scope) {\n            if (scope)\n                func = $.proxy(func, scope);\n            this._queue.queue(func);\n        }\n        pause() {\n            this._animator.pause();\n            this._balloon.pause();\n        }\n        resume() {\n            this._animator.resume();\n            this._balloon.resume();\n        }\n    }\n\n    return Agent;\n});\ndefine('skylark-clippy/loads',[\n    'skylark-jquery',\n    './Agent'\n], function ($, Agent) {\n    'use strict';\n    class load {\n        constructor(name, successCb, failCb, base_path) {\n            base_path = base_path || window.CLIPPY_CDN || 'https://gitcdn.xyz/repo/pi0/clippyjs/master/assets/agents/';\n            let path = base_path + name;\n            let mapDfd = load._loadMap(path);\n            let agentDfd = load._loadAgent(name, path);\n            let soundsDfd = load._loadSounds(name, path);\n            let data;\n            agentDfd.done(function (d) {\n                data = d;\n            });\n            let sounds;\n            soundsDfd.done(function (d) {\n                sounds = d;\n            });\n            let cb = function () {\n                let a = new Agent(path, data, sounds);\n                successCb(a);\n            };\n            $.when(mapDfd, agentDfd, soundsDfd).done(cb).fail(failCb);\n        }\n        static _loadMap(path) {\n            let dfd = load._maps[path];\n            if (dfd)\n                return dfd;\n            dfd = load._maps[path] = $.Deferred();\n            let src = path + '/map.png';\n            let img = new Image();\n            img.onload = dfd.resolve;\n            img.onerror = dfd.reject;\n            img.setAttribute('src', src);\n            return dfd.promise();\n        }\n        static _loadSounds(name, path) {\n            let dfd = load._sounds[name];\n            if (dfd)\n                return dfd;\n            dfd = load._sounds[name] = $.Deferred();\n            let audio = document.createElement('audio');\n            let canPlayMp3 = !!audio.canPlayType && '' !== audio.canPlayType('audio/mpeg');\n            let canPlayOgg = !!audio.canPlayType && '' !== audio.canPlayType('audio/ogg; codecs=\"vorbis\"');\n            if (!canPlayMp3 && !canPlayOgg) {\n                dfd.resolve({});\n            } else {\n                let src = path + (canPlayMp3 ? '/sounds-mp3.js' : '/sounds-ogg.js');\n                load._loadScript(src);\n            }\n            return dfd.promise();\n        }\n        static _loadAgent(name, path) {\n            let dfd = load._data[name];\n            if (dfd)\n                return dfd;\n            dfd = load._getAgentDfd(name);\n            let src = path + '/agent.js';\n            load._loadScript(src);\n            return dfd.promise();\n        }\n        static _loadScript(src) {\n            let script = document.createElement('script');\n            script.setAttribute('src', src);\n            script.setAttribute('async', 'async');\n            script.setAttribute('type', 'text/javascript');\n            document.head.appendChild(script);\n        }\n        static _getAgentDfd(name) {\n            let dfd = load._data[name];\n            if (!dfd) {\n                dfd = load._data[name] = $.Deferred();\n            }\n            return dfd;\n        }\n    }\n    load._maps = {};\n    load._sounds = {};\n    load._data = {};\n    function ready(name, data) {\n        let dfd = load._getAgentDfd(name);\n        dfd.resolve(data);\n    }\n    function soundsReady(name, data) {\n        let dfd = load._sounds[name];\n        if (!dfd) {\n            dfd = load._sounds[name] = $.Deferred();\n        }\n        dfd.resolve(data);\n    }\n    return {\n        load: load,\n        ready: ready,\n        soundsReady: soundsReady\n    };\n});\ndefine('skylark-clippy/main',[\n    \"skylark-langx/skylark\",\n    './Agent',\n    './Animator',\n    './Queue',\n    './Balloon',\n    './loads'\n], function (skylark,Agent, Animator, Queue, Balloon, loads) {\n    'use strict';\n\n    const clippy = {\n        Agent,\n        Animator,\n        Queue,\n        Balloon,\n        \"load\" : loads.load,\n        \"ready\": loads.ready,\n        \"soundsReady\": loads.soundsReady\n    };\n    return skylark.attach(\"intg.clippy\",clippy);\n\n});\ndefine('skylark-clippy', ['skylark-clippy/main'], function (main) { return main; });\n\n"]}